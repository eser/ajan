package datafx

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"slices"
	"strconv"
	"time"

	"github.com/eser/ajan/connfx"
)

var (
	ErrQueueStreamNotSupported = errors.New("connection does not support queue stream operations")
	ErrQueueStreamOperation    = errors.New("queue stream operation failed")
)

// QueueStream provides high-level stream operations for message streaming systems.
type QueueStream struct {
	conn       connfx.Connection
	repository connfx.QueueStreamRepository
}

// NewQueueStream creates a new QueueStream instance from a connfx connection.
// The connection must support stream operations.
func NewQueueStream(conn connfx.Connection) (*QueueStream, error) {
	if conn == nil {
		return nil, fmt.Errorf("%w: connection is nil", ErrConnectionNotSupported)
	}

	// Check if the connection supports queue operations (streams are a form of queues)
	capabilities := conn.GetCapabilities()
	supportsQueue := slices.Contains(capabilities, connfx.ConnectionCapabilityQueue)

	if !supportsQueue {
		return nil, fmt.Errorf("%w: connection does not support queue operations (protocol=%q)",
			ErrQueueStreamNotSupported, conn.GetProtocol())
	}

	// Get the stream repository from the raw connection
	repo, ok := conn.GetRawConnection().(connfx.QueueStreamRepository)
	if !ok {
		return nil, fmt.Errorf(
			"%w: connection does not implement QueueStreamRepository interface (protocol=%q)",
			ErrQueueStreamNotSupported,
			conn.GetProtocol(),
		)
	}

	return &QueueStream{
		conn:       conn,
		repository: repo,
	}, nil
}

// CreateStream creates a stream by sending the first message.
// For most stream systems, streams are created automatically when first written to.
func (s *QueueStream) CreateStream(ctx context.Context, streamName string) error {
	// Use QueueDeclare to create the stream
	_, err := s.repository.QueueDeclare(ctx, streamName)
	if err != nil {
		return fmt.Errorf(
			"%w (operation=create_stream, stream=%q): %w",
			ErrQueueStreamOperation,
			streamName,
			err,
		)
	}

	return nil
}

// CreateConsumerGroup creates a consumer group for a stream.
func (s *QueueStream) CreateConsumerGroup(
	ctx context.Context,
	streamName string,
	consumerGroup string,
	startFrom string,
) error {
	if startFrom == "" {
		startFrom = "0" // Start from beginning
	}

	err := s.repository.CreateConsumerGroup(ctx, streamName, consumerGroup, startFrom)
	if err != nil {
		return fmt.Errorf(
			"%w (operation=create_consumer_group, stream=%q, group=%q): %w",
			ErrQueueStreamOperation,
			streamName,
			consumerGroup,
			err,
		)
	}

	return nil
}

// SendMessage sends a message to a stream after marshaling it to JSON.
func (s *QueueStream) SendMessage(
	ctx context.Context,
	streamName string,
	message any,
) (string, error) {
	data, err := json.Marshal(message)
	if err != nil {
		return "", fmt.Errorf("%w (stream=%q): %w", ErrFailedToMarshal, streamName, err)
	}

	// For streams, we publish and return a message ID
	// The actual message ID would be generated by the stream system
	err = s.repository.Publish(ctx, streamName, data)
	if err != nil {
		return "", fmt.Errorf(
			"%w (operation=send_message, stream=%q): %w",
			ErrQueueStreamOperation,
			streamName,
			err,
		)
	}

	// Return a placeholder ID - in real implementations, this would be the actual message ID
	return strconv.FormatInt(time.Now().UnixNano(), 10), nil
}

// SendMessageWithHeaders sends a message with headers to a stream.
func (s *QueueStream) SendMessageWithHeaders(
	ctx context.Context,
	streamName string,
	message any,
	headers map[string]any,
) (string, error) {
	data, err := json.Marshal(message)
	if err != nil {
		return "", fmt.Errorf("%w (stream=%q): %w", ErrFailedToMarshal, streamName, err)
	}

	err = s.repository.PublishWithHeaders(ctx, streamName, data, headers)
	if err != nil {
		return "", fmt.Errorf(
			"%w (operation=send_message_with_headers, stream=%q): %w",
			ErrQueueStreamOperation,
			streamName,
			err,
		)
	}

	return strconv.FormatInt(time.Now().UnixNano(), 10), nil
}

// ConsumeFromGroup consumes messages from a stream as part of a consumer group.
func (s *QueueStream) ConsumeFromGroup(
	ctx context.Context,
	streamName string,
	consumerGroup string,
	consumerName string,
	config connfx.ConsumerConfig,
) (<-chan connfx.Message, <-chan error) {
	return s.repository.ConsumeWithGroup(ctx, streamName, consumerGroup, consumerName, config)
}

// ProcessMessagesFromGroup processes messages from a consumer group with automatic unmarshalling.
func (s *QueueStream) ProcessMessagesFromGroup(
	ctx context.Context,
	streamName string,
	consumerGroup string,
	consumerName string,
	config connfx.ConsumerConfig,
	messageHandler func(ctx context.Context, message any) bool,
	messageType any,
) error {
	messages, errors := s.repository.ConsumeWithGroup(
		ctx,
		streamName,
		consumerGroup,
		consumerName,
		config,
	)

	for {
		select {
		case <-ctx.Done():
			return fmt.Errorf("%w: %w", ErrContextCanceled, ctx.Err())
		case err := <-errors:
			if err != nil {
				return fmt.Errorf(
					"%w (stream=%q, group=%q): %w",
					ErrMessageProcessing,
					streamName,
					consumerGroup,
					err,
				)
			}
		case msg, ok := <-messages:
			if !ok {
				return nil // Channel closed
			}

			if err := s.processMessage(ctx, msg, messageHandler, messageType); err != nil {
				return err
			}
		}
	}
}

// ClaimPendingMessages claims pending messages from a consumer group that have been idle.
func (s *QueueStream) ClaimPendingMessages(
	ctx context.Context,
	streamName string,
	consumerGroup string,
	consumerName string,
	minIdleTime time.Duration,
	count int,
) ([]connfx.Message, error) {
	messages, err := s.repository.ClaimPendingMessages(
		ctx,
		streamName,
		consumerGroup,
		consumerName,
		minIdleTime,
		count,
	)
	if err != nil {
		return nil, fmt.Errorf(
			"%w (operation=claim_pending, stream=%q, group=%q): %w",
			ErrQueueStreamOperation,
			streamName,
			consumerGroup,
			err,
		)
	}

	return messages, nil
}

// AckMessage acknowledges a message in a consumer group.
func (s *QueueStream) AckMessage(
	ctx context.Context,
	streamName string,
	consumerGroup string,
	messageID string,
) error {
	err := s.repository.AckMessage(ctx, streamName, consumerGroup, messageID)
	if err != nil {
		return fmt.Errorf(
			"%w (operation=ack_message, stream=%q, group=%q, id=%q): %w",
			ErrQueueStreamOperation,
			streamName,
			consumerGroup,
			messageID,
			err,
		)
	}

	return nil
}

// GetStreamInfo returns information about a stream.
func (s *QueueStream) GetStreamInfo(
	ctx context.Context,
	streamName string,
) (connfx.StreamInfo, error) {
	info, err := s.repository.StreamInfo(ctx, streamName)
	if err != nil {
		return connfx.StreamInfo{}, fmt.Errorf(
			"%w (operation=stream_info, stream=%q): %w",
			ErrQueueStreamOperation,
			streamName,
			err,
		)
	}

	return info, nil
}

// GetConsumerGroupInfo returns information about consumer groups for a stream.
func (s *QueueStream) GetConsumerGroupInfo(
	ctx context.Context,
	streamName string,
) ([]connfx.ConsumerGroupInfo, error) {
	info, err := s.repository.ConsumerGroupInfo(ctx, streamName)
	if err != nil {
		return nil, fmt.Errorf(
			"%w (operation=consumer_group_info, stream=%q): %w",
			ErrQueueStreamOperation,
			streamName,
			err,
		)
	}

	return info, nil
}

// TrimStream trims a stream to a maximum length.
func (s *QueueStream) TrimStream(ctx context.Context, streamName string, maxLength int64) error {
	err := s.repository.TrimStream(ctx, streamName, maxLength)
	if err != nil {
		return fmt.Errorf(
			"%w (operation=trim_stream, stream=%q, maxLen=%d): %w",
			ErrQueueStreamOperation,
			streamName,
			maxLength,
			err,
		)
	}

	return nil
}

// GetConnection returns the underlying connfx connection.
func (s *QueueStream) GetConnection() connfx.Connection {
	return s.conn
}

// GetRepository returns the underlying stream repository.
func (s *QueueStream) GetRepository() connfx.QueueStreamRepository {
	return s.repository
}

// processMessage handles the processing of a single message.
func (s *QueueStream) processMessage(
	ctx context.Context,
	msg connfx.Message,
	messageHandler func(ctx context.Context, message any) bool,
	messageType any,
) error {
	// Create a new instance of the message type
	messageValue := s.createMessageInstance(messageType)

	// Unmarshal the message
	if err := json.Unmarshal(msg.Body, &messageValue); err != nil {
		// Nack the message due to unmarshalling error
		if nackErr := msg.Nack(false); nackErr != nil {
			return fmt.Errorf(
				"%w (operation=nack_after_unmarshal): %w",
				ErrQueueStreamOperation,
				nackErr,
			)
		}

		return nil // Continue processing other messages
	}

	// Process the message
	success := messageHandler(ctx, messageValue)

	// Acknowledge or nack based on processing result
	return s.acknowledgeMessage(msg, success)
}

// createMessageInstance creates an instance for unmarshalling the message.
func (s *QueueStream) createMessageInstance(messageType any) any {
	if messageType != nil {
		// Use the provided message type
		return messageType
	}

	// Default to generic map
	return make(map[string]any)
}

// acknowledgeMessage handles message acknowledgment based on processing success.
func (s *QueueStream) acknowledgeMessage(msg connfx.Message, success bool) error {
	if success {
		if err := msg.Ack(); err != nil {
			return fmt.Errorf("%w (operation=ack): %w", ErrQueueStreamOperation, err)
		}
	} else {
		if err := msg.Nack(true); err != nil { // Requeue on failure
			return fmt.Errorf("%w (operation=nack): %w", ErrQueueStreamOperation, err)
		}
	}

	return nil
}
