// Code generated by mockery v2.52.3. DO NOT EDIT.

package configfx_mock

import (
	configfx "github.com/eser/ajan/configfx"
	mock "github.com/stretchr/testify/mock"
)

// ConfigLoader is an autogenerated mock type for the ConfigLoader type
type ConfigLoader struct {
	mock.Mock
}

type ConfigLoader_Expecter struct {
	mock *mock.Mock
}

func (_m *ConfigLoader) EXPECT() *ConfigLoader_Expecter {
	return &ConfigLoader_Expecter{mock: &_m.Mock}
}

// FromEnvFile provides a mock function with given fields: filename
func (_m *ConfigLoader) FromEnvFile(filename string) configfx.ConfigResource {
	ret := _m.Called(filename)

	if len(ret) == 0 {
		panic("no return value specified for FromEnvFile")
	}

	var r0 configfx.ConfigResource
	if rf, ok := ret.Get(0).(func(string) configfx.ConfigResource); ok {
		r0 = rf(filename)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(configfx.ConfigResource)
		}
	}

	return r0
}

// ConfigLoader_FromEnvFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FromEnvFile'
type ConfigLoader_FromEnvFile_Call struct {
	*mock.Call
}

// FromEnvFile is a helper method to define mock.On call
//   - filename string
func (_e *ConfigLoader_Expecter) FromEnvFile(filename interface{}) *ConfigLoader_FromEnvFile_Call {
	return &ConfigLoader_FromEnvFile_Call{Call: _e.mock.On("FromEnvFile", filename)}
}

func (_c *ConfigLoader_FromEnvFile_Call) Run(run func(filename string)) *ConfigLoader_FromEnvFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *ConfigLoader_FromEnvFile_Call) Return(_a0 configfx.ConfigResource) *ConfigLoader_FromEnvFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ConfigLoader_FromEnvFile_Call) RunAndReturn(run func(string) configfx.ConfigResource) *ConfigLoader_FromEnvFile_Call {
	_c.Call.Return(run)
	return _c
}

// FromEnvFileDirect provides a mock function with given fields: filename
func (_m *ConfigLoader) FromEnvFileDirect(filename string) configfx.ConfigResource {
	ret := _m.Called(filename)

	if len(ret) == 0 {
		panic("no return value specified for FromEnvFileDirect")
	}

	var r0 configfx.ConfigResource
	if rf, ok := ret.Get(0).(func(string) configfx.ConfigResource); ok {
		r0 = rf(filename)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(configfx.ConfigResource)
		}
	}

	return r0
}

// ConfigLoader_FromEnvFileDirect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FromEnvFileDirect'
type ConfigLoader_FromEnvFileDirect_Call struct {
	*mock.Call
}

// FromEnvFileDirect is a helper method to define mock.On call
//   - filename string
func (_e *ConfigLoader_Expecter) FromEnvFileDirect(filename interface{}) *ConfigLoader_FromEnvFileDirect_Call {
	return &ConfigLoader_FromEnvFileDirect_Call{Call: _e.mock.On("FromEnvFileDirect", filename)}
}

func (_c *ConfigLoader_FromEnvFileDirect_Call) Run(run func(filename string)) *ConfigLoader_FromEnvFileDirect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *ConfigLoader_FromEnvFileDirect_Call) Return(_a0 configfx.ConfigResource) *ConfigLoader_FromEnvFileDirect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ConfigLoader_FromEnvFileDirect_Call) RunAndReturn(run func(string) configfx.ConfigResource) *ConfigLoader_FromEnvFileDirect_Call {
	_c.Call.Return(run)
	return _c
}

// FromJsonFile provides a mock function with given fields: filename
func (_m *ConfigLoader) FromJsonFile(filename string) configfx.ConfigResource {
	ret := _m.Called(filename)

	if len(ret) == 0 {
		panic("no return value specified for FromJsonFile")
	}

	var r0 configfx.ConfigResource
	if rf, ok := ret.Get(0).(func(string) configfx.ConfigResource); ok {
		r0 = rf(filename)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(configfx.ConfigResource)
		}
	}

	return r0
}

// ConfigLoader_FromJsonFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FromJsonFile'
type ConfigLoader_FromJsonFile_Call struct {
	*mock.Call
}

// FromJsonFile is a helper method to define mock.On call
//   - filename string
func (_e *ConfigLoader_Expecter) FromJsonFile(filename interface{}) *ConfigLoader_FromJsonFile_Call {
	return &ConfigLoader_FromJsonFile_Call{Call: _e.mock.On("FromJsonFile", filename)}
}

func (_c *ConfigLoader_FromJsonFile_Call) Run(run func(filename string)) *ConfigLoader_FromJsonFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *ConfigLoader_FromJsonFile_Call) Return(_a0 configfx.ConfigResource) *ConfigLoader_FromJsonFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ConfigLoader_FromJsonFile_Call) RunAndReturn(run func(string) configfx.ConfigResource) *ConfigLoader_FromJsonFile_Call {
	_c.Call.Return(run)
	return _c
}

// FromJsonFileDirect provides a mock function with given fields: filename
func (_m *ConfigLoader) FromJsonFileDirect(filename string) configfx.ConfigResource {
	ret := _m.Called(filename)

	if len(ret) == 0 {
		panic("no return value specified for FromJsonFileDirect")
	}

	var r0 configfx.ConfigResource
	if rf, ok := ret.Get(0).(func(string) configfx.ConfigResource); ok {
		r0 = rf(filename)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(configfx.ConfigResource)
		}
	}

	return r0
}

// ConfigLoader_FromJsonFileDirect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FromJsonFileDirect'
type ConfigLoader_FromJsonFileDirect_Call struct {
	*mock.Call
}

// FromJsonFileDirect is a helper method to define mock.On call
//   - filename string
func (_e *ConfigLoader_Expecter) FromJsonFileDirect(filename interface{}) *ConfigLoader_FromJsonFileDirect_Call {
	return &ConfigLoader_FromJsonFileDirect_Call{Call: _e.mock.On("FromJsonFileDirect", filename)}
}

func (_c *ConfigLoader_FromJsonFileDirect_Call) Run(run func(filename string)) *ConfigLoader_FromJsonFileDirect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *ConfigLoader_FromJsonFileDirect_Call) Return(_a0 configfx.ConfigResource) *ConfigLoader_FromJsonFileDirect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ConfigLoader_FromJsonFileDirect_Call) RunAndReturn(run func(string) configfx.ConfigResource) *ConfigLoader_FromJsonFileDirect_Call {
	_c.Call.Return(run)
	return _c
}

// FromSystemEnv provides a mock function with no fields
func (_m *ConfigLoader) FromSystemEnv() configfx.ConfigResource {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for FromSystemEnv")
	}

	var r0 configfx.ConfigResource
	if rf, ok := ret.Get(0).(func() configfx.ConfigResource); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(configfx.ConfigResource)
		}
	}

	return r0
}

// ConfigLoader_FromSystemEnv_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FromSystemEnv'
type ConfigLoader_FromSystemEnv_Call struct {
	*mock.Call
}

// FromSystemEnv is a helper method to define mock.On call
func (_e *ConfigLoader_Expecter) FromSystemEnv() *ConfigLoader_FromSystemEnv_Call {
	return &ConfigLoader_FromSystemEnv_Call{Call: _e.mock.On("FromSystemEnv")}
}

func (_c *ConfigLoader_FromSystemEnv_Call) Run(run func()) *ConfigLoader_FromSystemEnv_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ConfigLoader_FromSystemEnv_Call) Return(_a0 configfx.ConfigResource) *ConfigLoader_FromSystemEnv_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ConfigLoader_FromSystemEnv_Call) RunAndReturn(run func() configfx.ConfigResource) *ConfigLoader_FromSystemEnv_Call {
	_c.Call.Return(run)
	return _c
}

// Load provides a mock function with given fields: i, resources
func (_m *ConfigLoader) Load(i any, resources ...configfx.ConfigResource) error {
	_va := make([]interface{}, len(resources))
	for _i := range resources {
		_va[_i] = resources[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, i)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Load")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(any, ...configfx.ConfigResource) error); ok {
		r0 = rf(i, resources...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ConfigLoader_Load_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Load'
type ConfigLoader_Load_Call struct {
	*mock.Call
}

// Load is a helper method to define mock.On call
//   - i any
//   - resources ...configfx.ConfigResource
func (_e *ConfigLoader_Expecter) Load(i interface{}, resources ...interface{}) *ConfigLoader_Load_Call {
	return &ConfigLoader_Load_Call{Call: _e.mock.On("Load",
		append([]interface{}{i}, resources...)...)}
}

func (_c *ConfigLoader_Load_Call) Run(run func(i any, resources ...configfx.ConfigResource)) *ConfigLoader_Load_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]configfx.ConfigResource, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(configfx.ConfigResource)
			}
		}
		run(args[0].(any), variadicArgs...)
	})
	return _c
}

func (_c *ConfigLoader_Load_Call) Return(_a0 error) *ConfigLoader_Load_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ConfigLoader_Load_Call) RunAndReturn(run func(any, ...configfx.ConfigResource) error) *ConfigLoader_Load_Call {
	_c.Call.Return(run)
	return _c
}

// LoadDefaults provides a mock function with given fields: i
func (_m *ConfigLoader) LoadDefaults(i any) error {
	ret := _m.Called(i)

	if len(ret) == 0 {
		panic("no return value specified for LoadDefaults")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(any) error); ok {
		r0 = rf(i)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ConfigLoader_LoadDefaults_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadDefaults'
type ConfigLoader_LoadDefaults_Call struct {
	*mock.Call
}

// LoadDefaults is a helper method to define mock.On call
//   - i any
func (_e *ConfigLoader_Expecter) LoadDefaults(i interface{}) *ConfigLoader_LoadDefaults_Call {
	return &ConfigLoader_LoadDefaults_Call{Call: _e.mock.On("LoadDefaults", i)}
}

func (_c *ConfigLoader_LoadDefaults_Call) Run(run func(i any)) *ConfigLoader_LoadDefaults_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(any))
	})
	return _c
}

func (_c *ConfigLoader_LoadDefaults_Call) Return(_a0 error) *ConfigLoader_LoadDefaults_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ConfigLoader_LoadDefaults_Call) RunAndReturn(run func(any) error) *ConfigLoader_LoadDefaults_Call {
	_c.Call.Return(run)
	return _c
}

// LoadMap provides a mock function with given fields: resources
func (_m *ConfigLoader) LoadMap(resources ...configfx.ConfigResource) (*map[string]any, error) {
	_va := make([]interface{}, len(resources))
	for _i := range resources {
		_va[_i] = resources[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LoadMap")
	}

	var r0 *map[string]any
	var r1 error
	if rf, ok := ret.Get(0).(func(...configfx.ConfigResource) (*map[string]any, error)); ok {
		return rf(resources...)
	}
	if rf, ok := ret.Get(0).(func(...configfx.ConfigResource) *map[string]any); ok {
		r0 = rf(resources...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*map[string]any)
		}
	}

	if rf, ok := ret.Get(1).(func(...configfx.ConfigResource) error); ok {
		r1 = rf(resources...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConfigLoader_LoadMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadMap'
type ConfigLoader_LoadMap_Call struct {
	*mock.Call
}

// LoadMap is a helper method to define mock.On call
//   - resources ...configfx.ConfigResource
func (_e *ConfigLoader_Expecter) LoadMap(resources ...interface{}) *ConfigLoader_LoadMap_Call {
	return &ConfigLoader_LoadMap_Call{Call: _e.mock.On("LoadMap",
		append([]interface{}{}, resources...)...)}
}

func (_c *ConfigLoader_LoadMap_Call) Run(run func(resources ...configfx.ConfigResource)) *ConfigLoader_LoadMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]configfx.ConfigResource, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(configfx.ConfigResource)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *ConfigLoader_LoadMap_Call) Return(_a0 *map[string]any, _a1 error) *ConfigLoader_LoadMap_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ConfigLoader_LoadMap_Call) RunAndReturn(run func(...configfx.ConfigResource) (*map[string]any, error)) *ConfigLoader_LoadMap_Call {
	_c.Call.Return(run)
	return _c
}

// LoadMeta provides a mock function with given fields: i
func (_m *ConfigLoader) LoadMeta(i any) (configfx.ConfigItemMeta, error) {
	ret := _m.Called(i)

	if len(ret) == 0 {
		panic("no return value specified for LoadMeta")
	}

	var r0 configfx.ConfigItemMeta
	var r1 error
	if rf, ok := ret.Get(0).(func(any) (configfx.ConfigItemMeta, error)); ok {
		return rf(i)
	}
	if rf, ok := ret.Get(0).(func(any) configfx.ConfigItemMeta); ok {
		r0 = rf(i)
	} else {
		r0 = ret.Get(0).(configfx.ConfigItemMeta)
	}

	if rf, ok := ret.Get(1).(func(any) error); ok {
		r1 = rf(i)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConfigLoader_LoadMeta_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoadMeta'
type ConfigLoader_LoadMeta_Call struct {
	*mock.Call
}

// LoadMeta is a helper method to define mock.On call
//   - i any
func (_e *ConfigLoader_Expecter) LoadMeta(i interface{}) *ConfigLoader_LoadMeta_Call {
	return &ConfigLoader_LoadMeta_Call{Call: _e.mock.On("LoadMeta", i)}
}

func (_c *ConfigLoader_LoadMeta_Call) Run(run func(i any)) *ConfigLoader_LoadMeta_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(any))
	})
	return _c
}

func (_c *ConfigLoader_LoadMeta_Call) Return(_a0 configfx.ConfigItemMeta, _a1 error) *ConfigLoader_LoadMeta_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ConfigLoader_LoadMeta_Call) RunAndReturn(run func(any) (configfx.ConfigItemMeta, error)) *ConfigLoader_LoadMeta_Call {
	_c.Call.Return(run)
	return _c
}

// NewConfigLoader creates a new instance of ConfigLoader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewConfigLoader(t interface {
	mock.TestingT
	Cleanup(func())
}) *ConfigLoader {
	mock := &ConfigLoader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
